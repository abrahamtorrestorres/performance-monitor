<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Performance Monitor - Dashboard</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #667eea;
            --primary-dark: #5568d3;
            --secondary: #764ba2;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --dark: #1f2937;
            --light: #f9fafb;
            --gray: #6b7280;
            --border: #e5e7eb;
            --sidebar-bg: #1f2937;
            --sidebar-hover: #374151;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f3f4f6;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Login Screen */
        #login-screen {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            animation: fadeIn 0.5s ease-in;
        }

        .login-container {
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            width: 100%;
            max-width: 400px;
            animation: slideUp 0.5s ease-out;
        }

        .login-container h1 {
            color: var(--dark);
            margin-bottom: 10px;
            font-size: 26px;
            font-weight: 700;
            text-align: center;
            line-height: 1.2;
            word-spacing: 0;
        }
        
        .login-container h1::before {
            content: 'üöÄ';
            display: inline-block;
            margin-right: 8px;
            vertical-align: middle;
        }

        .login-container p {
            color: var(--gray);
            margin-bottom: 30px;
            font-size: 14px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: var(--dark);
            font-weight: 500;
            font-size: 14px;
        }

        .form-group input {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid var(--border);
            border-radius: 10px;
            font-size: 14px;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .form-group input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .btn {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: var(--gray);
        }

        /* Dashboard Layout */
        #dashboard {
            display: none;
            animation: fadeIn 0.5s ease-in;
        }

        .dashboard-layout {
            display: flex;
            min-height: 100vh;
        }

        /* Sidebar */
        .sidebar {
            width: 260px;
            background: var(--sidebar-bg);
            color: white;
            padding: 20px 0;
            position: fixed;
            height: 100vh;
            overflow-y: auto;
            z-index: 100;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
        }

        .sidebar-header {
            padding: 0 20px 30px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 20px;
        }

        .sidebar-header h1 {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .sidebar-header p {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
        }

        .sidebar-menu {
            list-style: none;
            padding: 0;
        }

        .sidebar-menu li {
            margin-bottom: 5px;
        }

        .sidebar-menu a {
            display: flex;
            align-items: center;
            padding: 12px 20px;
            color: rgba(255, 255, 255, 0.8);
            text-decoration: none;
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: 500;
        }

        .sidebar-menu a:hover,
        .sidebar-menu a.active {
            background: var(--sidebar-hover);
            color: white;
        }

        .sidebar-menu a span {
            margin-right: 12px;
            font-size: 18px;
        }

        .sidebar-footer {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            padding: 0 20px;
        }

        .logout-btn {
            width: 100%;
            padding: 12px;
            background: var(--danger);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .logout-btn:hover {
            background: #dc2626;
        }

        /* Main Content */
        .main-content {
            margin-left: 260px;
            flex: 1;
            padding: 20px 30px;
            overflow-y: auto;
            max-height: 100vh;
        }

        .page-header {
            margin-bottom: 20px;
        }

        .page-header h2 {
            font-size: 28px;
            font-weight: 700;
            color: var(--dark);
            margin-bottom: 8px;
        }

        .page-header p {
            color: var(--gray);
            font-size: 14px;
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: white;
            padding: 25px;
            border-radius: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            transition: all 0.3s ease;
            animation: slideUp 0.5s ease-out;
            animation-fill-mode: both;
            border-left: 4px solid var(--primary);
        }

        .stat-card:nth-child(1) { animation-delay: 0.1s; border-left-color: var(--primary); }
        .stat-card:nth-child(2) { animation-delay: 0.2s; border-left-color: var(--success); }
        .stat-card:nth-child(3) { animation-delay: 0.3s; border-left-color: var(--warning); }
        .stat-card:nth-child(4) { animation-delay: 0.4s; border-left-color: var(--secondary); }
        .stat-card:nth-child(5) { animation-delay: 0.5s; border-left-color: #3b82f6; }
        .stat-card:nth-child(6) { animation-delay: 0.6s; border-left-color: #8b5cf6; }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.12);
        }

        .stat-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .stat-card-title {
            color: var(--gray);
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-card-icon {
            font-size: 24px;
            opacity: 0.7;
        }

        .stat-card-value {
            font-size: 32px;
            font-weight: 700;
            color: var(--dark);
            margin-bottom: 5px;
        }

        .stat-card-change {
            font-size: 12px;
            color: var(--gray);
        }

        /* Charts */
        .charts-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .charts-grid.two-columns {
            grid-template-columns: 1fr 1fr;
        }

        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            animation: slideUp 0.5s ease-out 0.7s both;
            margin-bottom: 30px;
            min-height: 400px;
        }

        .chart-container h3 {
            color: var(--dark);
            margin-bottom: 15px;
            font-size: 18px;
            font-weight: 600;
        }

        .chart-wrapper {
            position: relative;
            height: 350px;
            min-height: 350px;
        }

        /* Hardware Information */
        .hardware-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .hardware-item {
            padding: 20px;
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            border-radius: 12px;
            border: 1px solid var(--border);
            transition: all 0.3s ease;
        }

        .hardware-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border-color: var(--primary);
        }

        .hardware-label {
            font-size: 11px;
            font-weight: 600;
            color: var(--gray);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .hardware-value {
            font-size: 16px;
            font-weight: 700;
            color: var(--dark);
            margin-bottom: 4px;
            word-break: break-word;
        }

        .hardware-detail {
            font-size: 11px;
            color: var(--gray);
        }

        /* Nodes Section */
        .nodes-section {
            background: white;
            padding: 25px;
            border-radius: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            margin-bottom: 30px;
            animation: slideUp 0.5s ease-out 0.8s both;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .section-header h3 {
            color: var(--dark);
            font-size: 18px;
            font-weight: 600;
        }

        .nodes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
        }

        .node-card {
            background: var(--light);
            padding: 20px;
            border-radius: 12px;
            border-left: 4px solid var(--success);
            transition: all 0.3s ease;
        }

        .node-card.offline {
            border-left-color: var(--danger);
        }

        .node-card:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .node-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 10px;
        }

        .node-name {
            font-weight: 600;
            color: var(--dark);
            font-size: 16px;
        }

        .node-status {
            font-size: 12px;
            padding: 4px 12px;
            border-radius: 12px;
            font-weight: 500;
        }

        .status-online {
            background: rgba(16, 185, 129, 0.1);
            color: var(--success);
        }

        .status-offline {
            background: rgba(239, 68, 68, 0.1);
            color: var(--danger);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s ease;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 20px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            animation: slideUp 0.3s ease-out;
        }

        .modal-content h2 {
            color: var(--dark);
            margin-bottom: 20px;
            font-size: 24px;
        }

        textarea {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid var(--border);
            border-radius: 10px;
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
            transition: all 0.3s ease;
        }

        textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .btn-group .btn {
            flex: 1;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: var(--gray);
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .charts-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(-100%);
                transition: transform 0.3s ease;
            }
            
            .main-content {
                margin-left: 0;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
            
            .nodes-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- Login Screen -->
    <div id="login-screen">
        <div class="login-container">
            <h1>Performance Monitor</h1>
            <p>Sign in to access your dashboard</p>
            <form id="login-form">
                <div class="form-group">
                    <label>Username</label>
                    <input type="text" id="username" placeholder="Enter your username" required autocomplete="username">
                </div>
                <div class="form-group">
                    <label>Password</label>
                    <input type="password" id="password" placeholder="Enter your password" required autocomplete="current-password">
                </div>
                <button type="button" class="btn" onclick="login()">Sign In</button>
            </form>
        </div>
    </div>

    <!-- Dashboard -->
    <div id="dashboard">
        <div class="dashboard-layout">
            <!-- Sidebar -->
            <aside class="sidebar">
                <div class="sidebar-header">
                    <h1>üìä Monitor</h1>
                    <p>Performance Dashboard</p>
                </div>
                <ul class="sidebar-menu">
                    <li><a href="#" data-page="dashboard" class="active"><span>üìà</span> Dashboard</a></li>
                    <li><a href="#" data-page="nodes"><span>üñ•Ô∏è</span> Nodes</a></li>
                    <li><a href="#" data-page="analytics"><span>üìä</span> Analytics</a></li>
                    <li><a href="#" data-page="settings"><span>‚öôÔ∏è</span> Settings</a></li>
                </ul>
                <div class="sidebar-footer">
                    <button class="logout-btn" onclick="logout()">Logout</button>
                </div>
            </aside>

            <!-- Main Content -->
            <main class="main-content">
                <!-- Dashboard Page -->
                <div id="page-dashboard" class="page-content">
                    <div class="page-header">
                        <h2>Dashboard Overview</h2>
                        <p>Real-time system performance and statistics</p>
                    </div>

                <!-- Stats Cards -->
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-card-header">
                            <div class="stat-card-title">CPU Usage</div>
                            <div class="stat-card-icon">‚ö°</div>
                        </div>
                        <div class="stat-card-value" id="stat-cpu">0.0%</div>
                        <div class="stat-card-change" id="stat-cpu-info">Loading...</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-card-header">
                            <div class="stat-card-title">Memory Usage</div>
                            <div class="stat-card-icon">üíæ</div>
                        </div>
                        <div class="stat-card-value" id="stat-memory">0.0%</div>
                        <div class="stat-card-change" id="stat-memory-info">Loading...</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-card-header">
                            <div class="stat-card-title">Storage Used</div>
                            <div class="stat-card-icon">üíø</div>
                        </div>
                        <div class="stat-card-value" id="stat-storage">0.0%</div>
                        <div class="stat-card-change" id="stat-storage-info">Loading...</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-card-header">
                            <div class="stat-card-title">Current Bandwidth</div>
                            <div class="stat-card-icon">üåê</div>
                        </div>
                        <div class="stat-card-value" id="stat-bandwidth">0 MB/s</div>
                        <div class="stat-card-change" id="stat-bandwidth-info">Current snapshot</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-card-header">
                            <div class="stat-card-title">Total Bandwidth</div>
                            <div class="stat-card-icon">üì°</div>
                        </div>
                        <div class="stat-card-value" id="stat-total-bandwidth">0 GB</div>
                        <div class="stat-card-change" id="stat-total-bandwidth-info">All time usage</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-card-header">
                            <div class="stat-card-title">Active Nodes</div>
                            <div class="stat-card-icon">üñ•Ô∏è</div>
                        </div>
                        <div class="stat-card-value" id="stat-nodes">0</div>
                        <div class="stat-card-change" id="stat-nodes-info">Total nodes</div>
                    </div>
                </div>

                <!-- Charts -->
                <div class="chart-container">
                    <h3>üìà Hourly Performance History</h3>
                    <div class="chart-wrapper">
                        <canvas id="history-chart"></canvas>
                    </div>
                </div>
                <div class="chart-container">
                    <h3>‚ö° Real-Time Performance (Last 5 min)</h3>
                    <div class="chart-wrapper">
                        <canvas id="realtime-chart"></canvas>
                    </div>
                </div>

                <!-- Hardware Information -->
                <div class="chart-container">
                    <h3>üñ•Ô∏è Hardware Information</h3>
                    <div class="hardware-info-grid">
                        <div class="hardware-item">
                            <div class="hardware-label">CPU</div>
                            <div class="hardware-value" id="hw-cpu-name">Loading...</div>
                            <div class="hardware-detail" id="hw-cpu-speed">-</div>
                        </div>
                        <div class="hardware-item">
                            <div class="hardware-label">GPU</div>
                            <div class="hardware-value" id="hw-gpu-name">Loading...</div>
                            <div class="hardware-detail">Graphics Processor</div>
                        </div>
                        <div class="hardware-item">
                            <div class="hardware-label">Temperature</div>
                            <div class="hardware-value" id="hw-temperature">Loading...</div>
                            <div class="hardware-detail">System Temperature</div>
                        </div>
                        <div class="hardware-item">
                            <div class="hardware-label">Operating System</div>
                            <div class="hardware-value" id="hw-os">Loading...</div>
                            <div class="hardware-detail" id="hw-kernel">-</div>
                        </div>
                        <div class="hardware-item">
                            <div class="hardware-label">Architecture</div>
                            <div class="hardware-value" id="hw-arch">Loading...</div>
                            <div class="hardware-detail" id="hw-platform">-</div>
                        </div>
                        <div class="hardware-item">
                            <div class="hardware-label">Hostname</div>
                            <div class="hardware-value" id="hw-hostname">Loading...</div>
                            <div class="hardware-detail">System Identifier</div>
                        </div>
                    </div>
                </div>
                </div>

                <!-- Nodes Page -->
                <div id="page-nodes" class="page-content" style="display: none;">
                    <div class="page-header">
                        <h2>Node Management</h2>
                        <p>Manage and monitor your server nodes</p>
                    </div>
                    <div class="nodes-section">
                        <div class="section-header">
                            <h3>üñ•Ô∏è Nodes</h3>
                            <button class="btn" onclick="openAddNodeModal()" style="width: auto; padding: 10px 20px;">+ Add Node</button>
                        </div>
                        <div id="nodes-list" class="nodes-grid">
                            <div class="loading">Loading nodes...</div>
                        </div>
                    </div>
                </div>

                <!-- Analytics Page -->
                <div id="page-analytics" class="page-content" style="display: none;">
                    <div class="page-header">
                        <h2>Analytics & Reports</h2>
                        <p>Detailed performance analytics and insights</p>
                    </div>
                    <div class="chart-container">
                        <h3>üìà Hourly Performance History</h3>
                        <div class="chart-wrapper">
                            <canvas id="analytics-history-chart"></canvas>
                        </div>
                    </div>
                    <div class="chart-container">
                        <h3>‚ö° Real-Time Performance (Last 5 min)</h3>
                        <div class="chart-wrapper">
                            <canvas id="analytics-realtime-chart"></canvas>
                        </div>
                    </div>
                    <div class="stats-grid" style="margin-top: 30px;">
                        <div class="stat-card">
                            <div class="stat-card-header">
                                <div class="stat-card-title">Average CPU</div>
                                <div class="stat-card-icon">‚ö°</div>
                            </div>
                            <div class="stat-card-value" id="analytics-avg-cpu">0.0%</div>
                            <div class="stat-card-change">Last 24 hours</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-card-header">
                                <div class="stat-card-title">Peak Memory</div>
                                <div class="stat-card-icon">üíæ</div>
                            </div>
                            <div class="stat-card-value" id="analytics-peak-memory">0.0%</div>
                            <div class="stat-card-change">Last 24 hours</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-card-header">
                                <div class="stat-card-title">Total Requests</div>
                                <div class="stat-card-icon">üìä</div>
                            </div>
                            <div class="stat-card-value" id="analytics-requests">0</div>
                            <div class="stat-card-change">All time</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-card-header">
                                <div class="stat-card-title">Uptime</div>
                                <div class="stat-card-icon">‚è±Ô∏è</div>
                            </div>
                            <div class="stat-card-value" id="analytics-uptime">0h</div>
                            <div class="stat-card-change">System uptime</div>
                        </div>
                    </div>
                </div>

                <!-- Settings Page -->
                <div id="page-settings" class="page-content" style="display: none;">
                    <div class="page-header">
                        <h2>Settings</h2>
                        <p>Configure your monitoring preferences</p>
                    </div>
                    <div class="chart-container">
                        <h3>‚öôÔ∏è General Settings</h3>
                        <div style="padding: 20px 0;">
                            <div class="form-group">
                                <label>Update Interval (seconds)</label>
                                <input type="number" id="update-interval" value="5" min="1" max="60" style="max-width: 200px;">
                                <p style="font-size: 12px; color: var(--gray); margin-top: 5px;">How often to refresh metrics</p>
                            </div>
                            <div class="form-group" style="margin-top: 20px;">
                                <label>
                                    <input type="checkbox" id="auto-refresh" checked style="margin-right: 8px;">
                                    Auto-refresh enabled
                                </label>
                            </div>
                            <div class="form-group" style="margin-top: 20px;">
                                <label>
                                    <input type="checkbox" id="notifications" checked style="margin-right: 8px;">
                                    Enable notifications
                                </label>
                            </div>
                            <button class="btn" onclick="saveSettings()" style="width: auto; padding: 10px 30px; margin-top: 20px;">Save Settings</button>
                        </div>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <!-- Add Node Modal -->
    <div id="node-modal" class="modal">
        <div class="modal-content">
            <h2 id="modal-title">Add Node</h2>
            <form id="node-form">
                <input type="hidden" id="node-id">
                <div class="form-group">
                    <label>Node Name *</label>
                    <input type="text" id="node-name" required placeholder="e.g., Production Server 1">
                </div>
                <div class="form-group">
                    <label>Host/IP Address *</label>
                    <input type="text" id="node-host" required placeholder="192.168.1.100 or example.com">
                </div>
                <div class="form-group">
                    <label>Port</label>
                    <input type="number" id="node-port" value="3000" min="1" max="65535">
                </div>
                <div class="form-group">
                    <label>API Key (Optional)</label>
                    <input type="text" id="node-api-key" placeholder="Leave empty if no authentication">
                </div>
                <div class="form-group">
                    <label>Location (Optional)</label>
                    <input type="text" id="node-location" placeholder="e.g., US-East, Data Center 1">
                </div>
                <div class="form-group">
                    <label>Description (Optional)</label>
                    <textarea id="node-description" rows="3" placeholder="Node description..."></textarea>
                </div>
                <div class="btn-group">
                    <button type="submit" class="btn">Save</button>
                    <button type="button" class="btn btn-secondary" onclick="closeNodeModal()">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        const API_BASE = '/api/v1';
        let historyChart = null;
        let realtimeChart = null;
        let analyticsHistoryChart = null;
        let analyticsRealtimeChart = null;
        let editingNodeId = null;
        
        // Hourly data (one point per hour)
        let hourlyData = {
            labels: [],
            cpu: [],
            memory: []
        };
        
        // Real-time data (updates every 5 seconds, shows last 5 minutes = 60 points)
        let realtimeData = {
            labels: [],
            cpu: [],
            memory: [],
            dataPoints: [],  // Store all data points with timestamps
            lastUpdateTime: 0  // Track when we last added a data point
        };
        
        let lastHourlyUpdate = null;

        // Authentication
        function checkAuth() {
            const isAuthenticated = sessionStorage.getItem('authenticated') === 'true';
            if (isAuthenticated) {
                showDashboard();
            } else {
                showLogin();
            }
        }

        function showLogin() {
            document.getElementById('login-screen').style.display = 'flex';
            document.getElementById('dashboard').style.display = 'none';
        }

        function showDashboard() {
            document.getElementById('login-screen').style.display = 'none';
            document.getElementById('dashboard').style.display = 'block';
            // Initialize dashboard asynchronously, but don't block on errors
            initializeDashboard().catch(error => {
                console.error('Error initializing dashboard:', error);
                // Still show dashboard even if initialization fails
            });
        }

        async function login() {
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;
            
            if (!username || !password) {
                alert('Please enter both username and password.');
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/auth/login`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, password })
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ message: 'Server error' }));
                    throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                console.log('Login response:', result);
                
                if (result.success) {
                    sessionStorage.setItem('authenticated', 'true');
                    sessionStorage.setItem('authToken', result.token || '');
                    showDashboard();
                } else {
                    alert(result.message || 'Invalid credentials. Please check your username and password.');
                }
            } catch (error) {
                console.error('Login error:', error);
                alert(`Login failed: ${error.message}`);
            }
        }

        async function logout() {
            try {
                await fetch(`${API_BASE}/auth/logout`, { method: 'POST' });
            } catch (error) {
                console.error('Logout error:', error);
            }
            sessionStorage.removeItem('authenticated');
            sessionStorage.removeItem('authToken');
            showLogin();
        }

        // Handle form submission as backup (button is type="button" so this shouldn't fire, but just in case)
        document.getElementById('login-form').addEventListener('submit', async function(e) {
            e.preventDefault();
            e.stopPropagation();
            await login();
            return false;
        });
        
        // Make login function globally accessible for onclick
        window.login = login;

        // Initialize Charts
        function initCharts() {
            // Hourly History Chart
            const historyCtx = document.getElementById('history-chart').getContext('2d');
            historyChart = new Chart(historyCtx, {
                type: 'line',
                data: {
                    labels: hourlyData.labels,
                    datasets: [
                        {
                            label: 'CPU Usage (%)',
                            data: hourlyData.cpu,
                            borderColor: '#667eea',
                            backgroundColor: 'rgba(102, 126, 234, 0.1)',
                            tension: 0.4,
                            fill: true,
                            spanGaps: true  // Connect lines across gaps using last known value
                        },
                        {
                            label: 'Memory Usage (%)',
                            data: hourlyData.memory,
                            borderColor: '#764ba2',
                            backgroundColor: 'rgba(118, 75, 162, 0.1)',
                            tension: 0.4,
                            fill: true,
                            spanGaps: true  // Connect lines across gaps using last known value
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100
                        },
                        x: {
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45,
                                autoSkip: true,
                                maxTicksLimit: 12,  // Show every 2 hours (12 labels for 24 hours)
                                callback: function(value, index) {
                                    // Show every 2nd hour label to avoid overcrowding
                                    if (index % 2 === 0 || index === hourlyData.labels.length - 1) {
                                        return hourlyData.labels[index];
                                    }
                                    return '';
                                }
                            },
                            grid: {
                                display: true
                            }
                        }
                    },
                    animation: {
                        duration: 1000
                    }
                }
            });

            // Real-time Chart
            const realtimeCtx = document.getElementById('realtime-chart').getContext('2d');
            realtimeChart = new Chart(realtimeCtx, {
                type: 'line',
                data: {
                    labels: realtimeData.labels,
                    datasets: [
                        {
                            label: 'CPU Usage (%)',
                            data: realtimeData.cpu,
                            borderColor: '#10b981',
                            backgroundColor: 'rgba(16, 185, 129, 0.1)',
                            tension: 0.4,
                            fill: true,
                            spanGaps: true  // Connect lines across gaps
                        },
                        {
                            label: 'Memory Usage (%)',
                            data: realtimeData.memory,
                            borderColor: '#f59e0b',
                            backgroundColor: 'rgba(245, 158, 11, 0.1)',
                            tension: 0.4,
                            fill: true,
                            spanGaps: true  // Connect lines across gaps
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100
                        }
                    },
                    animation: {
                        duration: 500
                    }
                }
            });

            // Analytics Hourly History Chart (same data as dashboard)
            const analyticsHistoryCtx = document.getElementById('analytics-history-chart').getContext('2d');
            analyticsHistoryChart = new Chart(analyticsHistoryCtx, {
                type: 'line',
                data: {
                    labels: hourlyData.labels,
                    datasets: [
                        {
                            label: 'CPU Usage (%)',
                            data: hourlyData.cpu,
                            borderColor: '#667eea',
                            backgroundColor: 'rgba(102, 126, 234, 0.1)',
                            tension: 0.4,
                            fill: true,
                            spanGaps: true
                        },
                        {
                            label: 'Memory Usage (%)',
                            data: hourlyData.memory,
                            borderColor: '#764ba2',
                            backgroundColor: 'rgba(118, 75, 162, 0.1)',
                            tension: 0.4,
                            fill: true,
                            spanGaps: true
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100
                        },
                        x: {
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45,
                                autoSkip: true,
                                maxTicksLimit: 12,
                                callback: function(value, index) {
                                    if (index % 2 === 0 || index === hourlyData.labels.length - 1) {
                                        return hourlyData.labels[index];
                                    }
                                    return '';
                                }
                            },
                            grid: {
                                display: true
                            }
                        }
                    },
                    animation: {
                        duration: 1000
                    }
                }
            });

            // Analytics charts will be initialized lazily when analytics page is shown
            // (Chart.js needs canvas to be visible to calculate dimensions properly)
            // See initAnalyticsCharts() function
        }

        // Track last save time for auto-saving metrics
        let lastMetricsSaveTime = 0;

        // Update stats
        async function updateStats() {
            try {
                const [systemRes, nodesRes] = await Promise.all([
                    fetch(`${API_BASE}/system/metrics`),
                    fetch(`${API_BASE}/nodes/status`)
                ]);

                if (systemRes.ok) {
                    const system = await systemRes.json();
                    if (system.success && system.data) {
                        const m = system.data;
                        
                        // Auto-save metrics to database every 30 seconds for historical data
                        const now = Date.now();
                        if (now - lastMetricsSaveTime >= 30000) {
                            lastMetricsSaveTime = now;
                            try {
                                await fetch(`${API_BASE}/system/collect`, { method: 'POST' });
                            } catch (error) {
                                console.error('Error auto-saving metrics:', error);
                            }
                        }
                        
                        // Update stat cards
                        document.getElementById('stat-cpu').textContent = `${m.cpuUsage.toFixed(1)}%`;
                        document.getElementById('stat-cpu-info').textContent = `${m.cpuCount} cores`;
                        document.getElementById('stat-memory').textContent = `${m.memoryUsage.toFixed(1)}%`;
                        document.getElementById('stat-memory-info').textContent = `${m.memoryUsed} / ${m.memoryTotal}`;
                        document.getElementById('stat-storage').textContent = `${m.storageUsage.toFixed(1)}%`;
                        document.getElementById('stat-storage-info').textContent = `${m.storageUsed} / ${m.storageTotal}`;
                        document.getElementById('stat-bandwidth').textContent = `${m.currentBandwidth.toFixed(2)} MB/s`;
                        document.getElementById('stat-total-bandwidth').textContent = m.totalBandwidthUsed;
                        
                        // Update hardware information
                        if (m.cpuName) {
                            document.getElementById('hw-cpu-name').textContent = m.cpuName;
                        }
                        if (m.cpuSpeed) {
                            document.getElementById('hw-cpu-speed').textContent = m.cpuSpeed;
                        }
                        if (m.gpuName) {
                            document.getElementById('hw-gpu-name').textContent = m.gpuName;
                        }
                        if (m.temperature) {
                            document.getElementById('hw-temperature').textContent = m.temperature;
                        }
                        if (m.osVersion) {
                            document.getElementById('hw-os').textContent = m.osVersion;
                        }
                        if (m.kernelVersion) {
                            document.getElementById('hw-kernel').textContent = `Kernel: ${m.kernelVersion}`;
                        }
                        if (m.arch) {
                            document.getElementById('hw-arch').textContent = m.arch.toUpperCase();
                        }
                        if (m.platform) {
                            document.getElementById('hw-platform').textContent = m.platform.charAt(0).toUpperCase() + m.platform.slice(1);
                        }
                        if (m.hostname) {
                            document.getElementById('hw-hostname').textContent = m.hostname;
                        }
                        
                        // Update real-time chart (rolling 5-minute window)
                        // Always show from (current time - 5 minutes) to current time
                        const currentTime = new Date();
                        const lastUpdateTime = realtimeData.lastUpdateTime || 0;
                        const timeSinceLastUpdate = currentTime.getTime() - lastUpdateTime;
                        
                        // Initialize dataPoints array if needed
                        if (!realtimeData.dataPoints) {
                            realtimeData.dataPoints = [];
                        }
                        
                        // Add new data point if at least 30 seconds have passed (or if it's the first update)
                        if (timeSinceLastUpdate >= 30000 || lastUpdateTime === 0) {
                            realtimeData.lastUpdateTime = currentTime.getTime();
                            
                            // Store current data point with timestamp
                            realtimeData.dataPoints.push({
                                timestamp: currentTime.getTime(),
                                cpu: m.cpuUsage,
                                memory: m.memoryUsage
                            });
                        }
                        
                        // Always regenerate labels for rolling 5-minute window (updates every stats refresh)
                        // Remove data points older than 5 minutes
                        const fiveMinutesAgo = currentTime.getTime() - 5 * 60 * 1000;
                        realtimeData.dataPoints = realtimeData.dataPoints.filter(
                            point => point.timestamp >= fiveMinutesAgo
                        );
                        
                        // Generate labels for rolling 5-minute window (10 points at 30-second intervals)
                        const labels = [];
                        const cpuData = [];
                        const memoryData = [];
                        
                        let lastKnownCpu = null;
                        let lastKnownMemory = null;
                        
                        for (let i = 9; i >= 0; i--) {
                            const pointTime = new Date(currentTime.getTime() - i * 30 * 1000);
                            const pointLabel = pointTime.toLocaleTimeString('en-US', { 
                                hour: '2-digit', 
                                minute: '2-digit',
                                second: '2-digit',
                                hour12: true 
                            });
                            
                            labels.push(pointLabel);
                            
                            // Find closest data point to this time (within 15 seconds)
                            const closestPoint = realtimeData.dataPoints.find(point => {
                                const diff = Math.abs(point.timestamp - pointTime.getTime());
                                return diff <= 15000; // 15 seconds tolerance
                            });
                            
                            if (i === 0) {
                                // Current time - always use latest metric value
                                lastKnownCpu = m.cpuUsage;
                                lastKnownMemory = m.memoryUsage;
                                cpuData.push(m.cpuUsage);
                                memoryData.push(m.memoryUsage);
                            } else {
                                // Find closest data point to this time (within 15 seconds)
                                const closestPoint = realtimeData.dataPoints.find(point => {
                                    const diff = Math.abs(point.timestamp - pointTime.getTime());
                                    return diff <= 15000; // 15 seconds tolerance
                                });
                                
                                if (closestPoint) {
                                    lastKnownCpu = closestPoint.cpu;
                                    lastKnownMemory = closestPoint.memory;
                                    cpuData.push(closestPoint.cpu);
                                    memoryData.push(closestPoint.memory);
                                } else {
                                    // Use last known value for gaps (forward fill)
                                    if (lastKnownCpu !== null && lastKnownMemory !== null) {
                                        cpuData.push(lastKnownCpu);
                                        memoryData.push(lastKnownMemory);
                                    } else {
                                        // No previous data - use current value as fallback
                                        cpuData.push(m.cpuUsage);
                                        memoryData.push(m.memoryUsage);
                                    }
                                }
                            }
                        }
                        
                        // Update chart data (always update labels to show current time window)
                        realtimeData.labels = labels;
                        realtimeData.cpu = cpuData;
                        realtimeData.memory = memoryData;
                        
                        if (realtimeChart) {
                            realtimeChart.data.labels = labels;
                            realtimeChart.data.datasets[0].data = cpuData;
                            realtimeChart.data.datasets[1].data = memoryData;
                            realtimeChart.update('none');
                        }
                        if (analyticsRealtimeChart) {
                            analyticsRealtimeChart.data.labels = labels;
                            analyticsRealtimeChart.data.datasets[0].data = cpuData;
                            analyticsRealtimeChart.data.datasets[1].data = memoryData;
                            analyticsRealtimeChart.update('none');
                        }
                        
                        // Update hourly chart (once per hour)
                        // Only add new hourly data point if we've crossed into a new hour
                        const currentHour = new Date().getHours();
                        const currentDate = new Date().toDateString();
                        const hourKey = `${currentDate} ${currentHour}:00`;
                        
                        if (!lastHourlyUpdate || lastHourlyUpdate !== hourKey) {
                            lastHourlyUpdate = hourKey;
                            const hourLabel = new Date().toLocaleTimeString('en-US', { 
                                hour: '2-digit', 
                                minute: '2-digit',
                                hour12: true 
                            });
                            
                            // Check if this hour already exists (from historical data)
                            const hourExists = hourlyData.labels.some((label, idx) => {
                                // Simple check - if we have data for this hour, update it instead of adding
                                return false; // Always add new hour for now
                            });
                            
                            if (!hourExists) {
                                hourlyData.labels.push(hourLabel);
                                hourlyData.cpu.push(m.cpuUsage);
                                hourlyData.memory.push(m.memoryUsage);
                                
                                // Keep only last 24 hours
                                if (hourlyData.labels.length > 24) {
                                    hourlyData.labels.shift();
                                    hourlyData.cpu.shift();
                                    hourlyData.memory.shift();
                                }
                            }
                            
                            if (historyChart) {
                                historyChart.update();
                            }
                            if (analyticsHistoryChart) {
                                analyticsHistoryChart.update();
                            }
                        }
                    }
                }

                if (nodesRes.ok) {
                    const nodes = await nodesRes.json();
                    if (nodes.success) {
                        const onlineNodes = nodes.data.filter(n => n.status === 'online').length;
                        document.getElementById('stat-nodes').textContent = onlineNodes;
                        document.getElementById('stat-nodes-info').textContent = `${nodes.data.length} total nodes`;
                    }
                }
            } catch (error) {
                console.error('Error updating stats:', error);
            }
        }

        // Load nodes
        async function loadNodes() {
            const nodesDiv = document.getElementById('nodes-list');
            try {
                const response = await fetch(`${API_BASE}/nodes/status`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                
                const result = await response.json();
                if (result.success && result.data) {
                    const nodes = result.data;
                    if (nodes.length === 0) {
                        nodesDiv.innerHTML = '<div class="loading">No nodes configured. Click "Add Node" to get started.</div>';
                        return;
                    }
                    
                    let html = '';
                    nodes.forEach(node => {
                        const statusClass = node.status === 'online' ? 'status-online' : 'status-offline';
                        const lastSeen = node.last_seen ? new Date(node.last_seen).toLocaleString() : 'Never';
                        
                        html += `
                            <div class="node-card ${node.status === 'offline' ? 'offline' : ''}">
                                <div class="node-header">
                                    <div class="node-name">${node.name}</div>
                                    <div class="node-status ${statusClass}">${node.status.toUpperCase()}</div>
                                </div>
                                <div style="font-size: 13px; color: var(--gray); line-height: 1.8; margin-top: 10px;">
                                    <div><strong>Host:</strong> ${node.host}:${node.port}</div>
                                    ${node.location ? `<div><strong>Location:</strong> ${node.location}</div>` : ''}
                                    <div><strong>Last Seen:</strong> ${lastSeen}</div>
                                    ${node.statusCheck?.latency ? `<div><strong>Latency:</strong> ${node.statusCheck.latency}ms</div>` : ''}
                                </div>
                                <div style="margin-top: 15px; display: flex; gap: 8px;">
                                    <button onclick="editNode('${node.id}')" style="flex: 1; padding: 8px; background: var(--primary); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 12px; font-weight: 500;">Edit</button>
                                    <button onclick="deleteNode('${node.id}')" style="flex: 1; padding: 8px; background: var(--danger); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 12px; font-weight: 500;">Delete</button>
                                </div>
                            </div>
                        `;
                    });
                    nodesDiv.innerHTML = html;
                }
            } catch (error) {
                console.error('Error loading nodes:', error);
                nodesDiv.innerHTML = `<div class="loading" style="color: var(--danger);">Error: ${error.message}</div>`;
            }
        }

        // Node management
        function openAddNodeModal() {
            editingNodeId = null;
            document.getElementById('modal-title').textContent = 'Add Node';
            document.getElementById('node-form').reset();
            document.getElementById('node-port').value = '3000';
            document.getElementById('node-modal').style.display = 'flex';
        }

        function closeNodeModal() {
            document.getElementById('node-modal').style.display = 'none';
            document.getElementById('node-form').reset();
            editingNodeId = null;
        }

        async function saveNode() {
            const formData = {
                name: document.getElementById('node-name').value,
                host: document.getElementById('node-host').value,
                port: parseInt(document.getElementById('node-port').value) || 3000,
                api_key: document.getElementById('node-api-key').value || null,
                location: document.getElementById('node-location').value || null,
                description: document.getElementById('node-description').value || null
            };

            try {
                const url = editingNodeId 
                    ? `${API_BASE}/nodes/${editingNodeId}`
                    : `${API_BASE}/nodes`;
                const method = editingNodeId ? 'PUT' : 'POST';

                const response = await fetch(url, {
                    method: method,
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(formData)
                });

                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                
                const result = await response.json();
                if (result.success) {
                    closeNodeModal();
                    await loadNodes();
                    await updateStats();
                }
            } catch (error) {
                console.error('Error saving node:', error);
                alert('Error saving node: ' + error.message);
            }
        }

        async function editNode(id) {
            try {
                const response = await fetch(`${API_BASE}/nodes/${id}`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                
                const result = await response.json();
                if (result.success && result.data) {
                    const node = result.data;
                    editingNodeId = id;
                    document.getElementById('modal-title').textContent = 'Edit Node';
                    document.getElementById('node-id').value = id;
                    document.getElementById('node-name').value = node.name;
                    document.getElementById('node-host').value = node.host;
                    document.getElementById('node-port').value = node.port;
                    document.getElementById('node-api-key').value = node.api_key || '';
                    document.getElementById('node-location').value = node.location || '';
                    document.getElementById('node-description').value = node.description || '';
                    document.getElementById('node-modal').style.display = 'flex';
                }
            } catch (error) {
                console.error('Error loading node:', error);
                alert('Error loading node: ' + error.message);
            }
        }

        async function deleteNode(id) {
            if (!confirm('Are you sure you want to delete this node?')) return;
            
            try {
                const response = await fetch(`${API_BASE}/nodes/${id}`, { method: 'DELETE' });
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                
                const result = await response.json();
                if (result.success) {
                    await loadNodes();
                    await updateStats();
                }
            } catch (error) {
                console.error('Error deleting node:', error);
                alert('Error deleting node: ' + error.message);
            }
        }

        window.editNode = editNode;
        window.deleteNode = deleteNode;

        document.getElementById('node-form').addEventListener('submit', (e) => {
            e.preventDefault();
            saveNode();
        });

        // Navigation
        function navigateToPage(pageName) {
            // Hide all pages
            document.querySelectorAll('.page-content').forEach(page => {
                page.style.display = 'none';
            });
            
            // Show selected page
            const targetPage = document.getElementById(`page-${pageName}`);
            if (targetPage) {
                targetPage.style.display = 'block';
                
                // If analytics page, ensure charts are initialized/updated
                if (pageName === 'analytics') {
                    console.log('Navigating to analytics page, initializing charts...');
                    // Wait a bit for the page to be visible, then initialize/update charts
                    setTimeout(() => {
                        console.log('Calling initAnalyticsCharts after delay');
                        initAnalyticsCharts();
                    }, 100);
                }
            }
            
            // Update active menu item
            document.querySelectorAll('.sidebar-menu a').forEach(link => {
                link.classList.remove('active');
            });
            document.querySelector(`.sidebar-menu a[data-page="${pageName}"]`).classList.add('active');
        }
        
        // Initialize analytics charts (called when analytics page is shown)
        function initAnalyticsCharts() {
            console.log('Initializing analytics charts...');
            console.log('Chart.js available:', typeof Chart !== 'undefined');
            console.log('Hourly data:', hourlyData);
            console.log('Realtime data:', realtimeData);
            
            // Check if Chart.js is loaded
            if (typeof Chart === 'undefined') {
                console.error('Chart.js is not loaded!');
                return;
            }
            
            // Check if charts already exist, if not create them
            if (!analyticsHistoryChart) {
                try {
                    const analyticsHistoryCtx = document.getElementById('analytics-history-chart');
                    console.log('Analytics history canvas found:', analyticsHistoryCtx);
                    if (analyticsHistoryCtx) {
                        // Ensure we have at least empty arrays
                        const labels = hourlyData.labels || [];
                        const cpuData = hourlyData.cpu || [];
                        const memoryData = hourlyData.memory || [];
                        console.log('Creating history chart with', labels.length, 'data points');
                        analyticsHistoryChart = new Chart(analyticsHistoryCtx.getContext('2d'), {
                            type: 'line',
                            data: {
                                labels: labels,
                                datasets: [
                                    {
                                        label: 'CPU Usage (%)',
                                        data: cpuData,
                                        borderColor: '#667eea',
                                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                                        tension: 0.4,
                                        fill: true,
                                        spanGaps: true
                                    },
                                    {
                                        label: 'Memory Usage (%)',
                                        data: memoryData,
                                        borderColor: '#764ba2',
                                        backgroundColor: 'rgba(118, 75, 162, 0.1)',
                                        tension: 0.4,
                                        fill: true,
                                        spanGaps: true
                                    }
                                ]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                plugins: {
                                    legend: {
                                        display: true,
                                        position: 'top'
                                    }
                                },
                                scales: {
                                    y: {
                                        beginAtZero: true,
                                        max: 100
                                    },
                                    x: {
                                        ticks: {
                                            maxRotation: 45,
                                            minRotation: 45,
                                            autoSkip: true,
                                            maxTicksLimit: 12,
                                            callback: function(value, index) {
                                                if (index % 2 === 0 || index === hourlyData.labels.length - 1) {
                                                    return hourlyData.labels[index];
                                                }
                                                return '';
                                            }
                                        },
                                        grid: {
                                            display: true
                                        }
                                    }
                                },
                                animation: {
                                    duration: 1000
                                }
                            }
                        });
                        console.log('Analytics history chart created successfully');
                        // Resize chart after a brief delay to ensure proper rendering
                        setTimeout(() => {
                            if (analyticsHistoryChart) {
                                analyticsHistoryChart.resize();
                            }
                        }, 200);
                    } else {
                        console.error('Analytics history canvas not found!');
                    }
                } catch (error) {
                    console.error('Error initializing analytics history chart:', error);
                }
            } else {
                // Update existing chart with latest data
                console.log('Updating existing analytics history chart');
                analyticsHistoryChart.data.labels = hourlyData.labels;
                analyticsHistoryChart.data.datasets[0].data = hourlyData.cpu;
                analyticsHistoryChart.data.datasets[1].data = hourlyData.memory;
                analyticsHistoryChart.update();
            }
            
            if (!analyticsRealtimeChart) {
                try {
                    const analyticsRealtimeCtx = document.getElementById('analytics-realtime-chart');
                    console.log('Analytics realtime canvas found:', analyticsRealtimeCtx);
                    if (analyticsRealtimeCtx) {
                        // Ensure we have at least empty arrays
                        const realtimeLabels = realtimeData.labels || [];
                        const realtimeCpuData = realtimeData.cpu || [];
                        const realtimeMemoryData = realtimeData.memory || [];
                        console.log('Creating realtime chart with', realtimeLabels.length, 'data points');
                        analyticsRealtimeChart = new Chart(analyticsRealtimeCtx.getContext('2d'), {
                            type: 'line',
                            data: {
                                labels: realtimeLabels,
                                datasets: [
                                    {
                                        label: 'CPU Usage (%)',
                                        data: realtimeCpuData,
                                        borderColor: '#10b981',
                                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                        tension: 0.4,
                                        fill: true,
                                        spanGaps: true
                                    },
                                    {
                                        label: 'Memory Usage (%)',
                                        data: realtimeMemoryData,
                                        borderColor: '#f59e0b',
                                        backgroundColor: 'rgba(245, 158, 11, 0.1)',
                                        tension: 0.4,
                                        fill: true,
                                        spanGaps: true
                                    }
                                ]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                plugins: {
                                    legend: {
                                        display: true,
                                        position: 'top'
                                    }
                                },
                                scales: {
                                    y: {
                                        beginAtZero: true,
                                        max: 100
                                    }
                                },
                                animation: {
                                    duration: 500
                                }
                            }
                        });
                        console.log('Analytics realtime chart created successfully');
                        // Resize chart after a brief delay to ensure proper rendering
                        setTimeout(() => {
                            if (analyticsRealtimeChart) {
                                analyticsRealtimeChart.resize();
                            }
                        }, 200);
                    } else {
                        console.error('Analytics realtime canvas not found!');
                    }
                } catch (error) {
                    console.error('Error initializing analytics realtime chart:', error);
                }
            } else {
                // Update existing chart with latest data
                console.log('Updating existing analytics realtime chart');
                analyticsRealtimeChart.data.labels = realtimeData.labels;
                analyticsRealtimeChart.data.datasets[0].data = realtimeData.cpu;
                analyticsRealtimeChart.data.datasets[1].data = realtimeData.memory;
                analyticsRealtimeChart.update();
            }
            console.log('Analytics charts initialization complete');
        }

        // Setup sidebar navigation
        document.querySelectorAll('.sidebar-menu a').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const page = link.getAttribute('data-page');
                if (page) {
                    navigateToPage(page);
                }
            });
        });

        // Settings
        function saveSettings() {
            const interval = parseInt(document.getElementById('update-interval').value);
            const autoRefresh = document.getElementById('auto-refresh').checked;
            const notifications = document.getElementById('notifications').checked;
            
            // Save to localStorage
            localStorage.setItem('updateInterval', interval);
            localStorage.setItem('autoRefresh', autoRefresh);
            localStorage.setItem('notifications', notifications);
            
            alert('Settings saved successfully!');
            
            // Apply settings
            if (updateStatsInterval) {
                clearInterval(updateStatsInterval);
            }
            if (autoRefresh) {
                updateStatsInterval = setInterval(updateStats, interval * 1000);
            }
        }

        // Load settings
        function loadSettings() {
            const interval = localStorage.getItem('updateInterval') || 5;
            const autoRefresh = localStorage.getItem('autoRefresh') !== 'false';
            const notifications = localStorage.getItem('notifications') !== 'false';
            
            document.getElementById('update-interval').value = interval;
            document.getElementById('auto-refresh').checked = autoRefresh;
            document.getElementById('notifications').checked = notifications;
        }

        let updateStatsInterval = null;

        // Load real-time historical data (last 5 minutes)
        async function loadRealtimeHistoricalData() {
            try {
                // Get last 5 minutes of data
                const endDate = new Date().toISOString();
                const startDate = new Date(Date.now() - 5 * 60 * 1000).toISOString();
                
                const response = await fetch(`${API_BASE}/performance/metrics?startDate=${startDate}&endDate=${endDate}&limit=1000`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                
                const result = await response.json();
                if (result.success && result.data && result.data.length > 0) {
                    // Sort by timestamp (oldest first)
                    const sortedMetrics = result.data.sort((a, b) => 
                        new Date(a.timestamp) - new Date(b.timestamp)
                    );
                    
                    // Populate real-time chart with historical data
                    // Store data points with timestamps
                    realtimeData.dataPoints = [];
                    
                    sortedMetrics.forEach(metric => {
                        const date = new Date(metric.timestamp);
                        realtimeData.dataPoints.push({
                            timestamp: date.getTime(),
                            label: date.toLocaleTimeString('en-US', { 
                                hour: '2-digit', 
                                minute: '2-digit',
                                second: '2-digit',
                                hour12: true 
                            }),
                            cpu: parseFloat(metric.cpu_usage) || 0,
                            memory: parseFloat(metric.memory_usage) || 0
                        });
                    });
                    
                    // Generate rolling 5-minute window from current time
                    const currentTime = new Date();
                    const labels = [];
                    const cpuData = [];
                    const memoryData = [];
                    
                    for (let i = 9; i >= 0; i--) {
                        const pointTime = new Date(currentTime.getTime() - i * 30 * 1000);
                        const pointLabel = pointTime.toLocaleTimeString('en-US', { 
                            hour: '2-digit', 
                            minute: '2-digit',
                            second: '2-digit',
                            hour12: true 
                        });
                        
                        labels.push(pointLabel);
                        
                        // Find closest data point to this time (within 15 seconds)
                        const closestPoint = realtimeData.dataPoints.find(point => {
                            const diff = Math.abs(point.timestamp - pointTime.getTime());
                            return diff <= 15000; // 15 seconds tolerance
                        });
                        
                        if (closestPoint) {
                            cpuData.push(closestPoint.cpu);
                            memoryData.push(closestPoint.memory);
                        } else {
                            cpuData.push(null);
                            memoryData.push(null);
                        }
                    }
                    
                    realtimeData.labels = labels;
                    realtimeData.cpu = cpuData;
                    realtimeData.memory = memoryData;
                    
                    // Set last update time
                    if (realtimeData.dataPoints.length > 0) {
                        const lastPoint = realtimeData.dataPoints[realtimeData.dataPoints.length - 1];
                        realtimeData.lastUpdateTime = lastPoint.timestamp;
                    } else {
                        realtimeData.lastUpdateTime = 0;
                    }
                    
                    // Update analytics chart if it exists
                    if (analyticsRealtimeChart) {
                        analyticsRealtimeChart.data.labels = labels;
                        analyticsRealtimeChart.data.datasets[0].data = cpuData;
                        analyticsRealtimeChart.data.datasets[1].data = memoryData;
                        analyticsRealtimeChart.update();
                    }
                    
                    console.log(`Loaded ${realtimeData.labels.length} real-time historical data points`);
                } else {
                    console.log('No real-time historical data found');
                }
            } catch (error) {
                console.error('Error loading real-time historical data:', error);
            }
        }

        // Load historical data for hourly chart
        async function loadHistoricalData() {
            try {
                // Get last 24 hours of data (or all data if less than 24 hours)
                const endDate = new Date().toISOString();
                const startDate = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();
                
                console.log('Loading historical data from', startDate, 'to', endDate);
                const response = await fetch(`${API_BASE}/performance/metrics?startDate=${startDate}&endDate=${endDate}&limit=1000`);
                if (!response.ok) {
                    console.error('Failed to fetch historical data:', response.status, response.statusText);
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                console.log('Historical data response:', result);
                
                if (result.success && result.data && result.data.length > 0) {
                    console.log(`Found ${result.data.length} historical metrics`);
                    
                    // Group metrics by hour
                    const hourlyMap = new Map();
                    
                    result.data.forEach(metric => {
                        const date = new Date(metric.timestamp);
                        const hourKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:00`;
                        
                        if (!hourlyMap.has(hourKey)) {
                            hourlyMap.set(hourKey, { cpu: [], memory: [] });
                        }
                        
                        const hourData = hourlyMap.get(hourKey);
                        hourData.cpu.push(parseFloat(metric.cpu_usage) || 0);
                        hourData.memory.push(parseFloat(metric.memory_usage) || 0);
                    });
                    
                    console.log(`Grouped into ${hourlyMap.size} hours`);
                    
                    // Generate all hours in the last 24 hours (consistent intervals)
                    const now = new Date();
                    const hours = [];
                    for (let i = 23; i >= 0; i--) {
                        const hourDate = new Date(now.getTime() - i * 60 * 60 * 1000);
                        hourDate.setMinutes(0, 0, 0); // Set to start of hour
                        const hourKey = `${hourDate.getFullYear()}-${String(hourDate.getMonth() + 1).padStart(2, '0')}-${String(hourDate.getDate()).padStart(2, '0')} ${String(hourDate.getHours()).padStart(2, '0')}:00`;
                        hours.push({ hourKey, hourDate });
                    }
                    
                    // Populate chart with all hours (fill missing hours with null)
                    hourlyData.labels = [];
                    hourlyData.cpu = [];
                    hourlyData.memory = [];
                    
                    // First pass: collect all data with forward-fill for gaps
                    const tempLabels = [];
                    const tempCpu = [];
                    const tempMemory = [];
                    
                    let lastCpu = null;
                    let lastMemory = null;
                    let firstDataIndex = -1; // Track where first actual data appears
                    
                    hours.forEach(({ hourKey, hourDate }, index) => {
                        // Format hour label consistently (e.g., "10:00 PM" or "01:00 AM")
                        const hour = hourDate.getHours();
                        const hour12 = hour === 0 ? 12 : hour > 12 ? hour - 12 : hour;
                        const ampm = hour >= 12 ? 'PM' : 'AM';
                        const hourLabel = `${String(hour12).padStart(2, '0')}:00 ${ampm}`;
                        
                        if (hourlyMap.has(hourKey)) {
                            const data = hourlyMap.get(hourKey);
                            const avgCpu = data.cpu.reduce((a, b) => a + b, 0) / data.cpu.length;
                            const avgMemory = data.memory.reduce((a, b) => a + b, 0) / data.memory.length;
                            lastCpu = Math.round(avgCpu * 100) / 100;
                            lastMemory = Math.round(avgMemory * 100) / 100;
                            
                            // Mark first data point
                            if (firstDataIndex === -1) {
                                firstDataIndex = index;
                            }
                            
                            tempLabels.push(hourLabel);
                            tempCpu.push(lastCpu);
                            tempMemory.push(lastMemory);
                        } else {
                            // No data for this hour
                            if (lastCpu !== null && lastMemory !== null) {
                                // We have previous data - interpolate (forward-fill) for gaps in the middle
                                tempLabels.push(hourLabel);
                                tempCpu.push(lastCpu);
                                tempMemory.push(lastMemory);
                            } else {
                                // No previous data - this is an empty gap at the beginning
                                // Don't add it yet, we'll trim it later
                                tempLabels.push(hourLabel);
                                tempCpu.push(null);
                                tempMemory.push(null);
                            }
                        }
                    });
                    
                    // Second pass: trim empty beginning, keep interpolated middle gaps
                    if (firstDataIndex === -1) {
                        // No data at all - keep empty arrays
                        hourlyData.labels = [];
                        hourlyData.cpu = [];
                        hourlyData.memory = [];
                    } else {
                        // Start from first data point (trim empty beginning)
                        // But keep interpolated values in the middle
                        let foundFirstData = false;
                        for (let i = 0; i < tempLabels.length; i++) {
                            if (tempCpu[i] !== null && tempMemory[i] !== null) {
                                foundFirstData = true;
                            }
                            
                            // Once we find first data, include everything (including interpolated middle gaps)
                            if (foundFirstData) {
                                hourlyData.labels.push(tempLabels[i]);
                                hourlyData.cpu.push(tempCpu[i]);
                                hourlyData.memory.push(tempMemory[i]);
                            }
                        }
                    }
                    
                    console.log(`Populated ${hourlyData.labels.length} hours of data (with consistent intervals)`);
                    
                    // Update chart if it already exists (for updates after initial load)
                    if (historyChart) {
                        historyChart.data.labels = hourlyData.labels;
                        historyChart.data.datasets[0].data = hourlyData.cpu;
                        historyChart.data.datasets[1].data = hourlyData.memory;
                        historyChart.update();
                    }
                    if (analyticsHistoryChart) {
                        analyticsHistoryChart.data.labels = hourlyData.labels;
                        analyticsHistoryChart.data.datasets[0].data = hourlyData.cpu;
                        analyticsHistoryChart.data.datasets[1].data = hourlyData.memory;
                        analyticsHistoryChart.update();
                    }
                } else {
                    console.log('No historical data found in database. Chart will start empty.');
                    // Initialize with empty arrays if no data
                    hourlyData.labels = [];
                    hourlyData.cpu = [];
                    hourlyData.memory = [];
                }
            } catch (error) {
                console.error('Error loading historical data:', error);
                // Initialize with empty arrays on error
                hourlyData.labels = [];
                hourlyData.cpu = [];
                hourlyData.memory = [];
            }
        }

        // Initialize dashboard
        async function initializeDashboard() {
            // Load historical data FIRST (both hourly and real-time), then initialize charts with the data
            await Promise.all([
                loadHistoricalData(),
                loadRealtimeHistoricalData()
            ]);
            
            // Now initialize charts with the populated historical data
            initCharts();
            
            // Load current stats and nodes immediately
            await Promise.all([
                updateStats(),
                loadNodes()
            ]);
            
            loadSettings();
            
            const interval = parseInt(localStorage.getItem('updateInterval') || 5);
            updateStatsInterval = setInterval(updateStats, interval * 1000);
            setInterval(loadNodes, 10000); // Update nodes every 10 seconds
        }

        // Check auth on load
        checkAuth();
    </script>
</body>
</html>
